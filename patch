diff --git a/consensus/istanbul/config.go b/consensus/istanbul/config.go
index 7d187ccb5..73d07ef6c 100644
--- a/consensus/istanbul/config.go
+++ b/consensus/istanbul/config.go
@@ -23,10 +23,10 @@ import (
 
 type ProposerPolicy uint64
 
+// Permute proposers using block randomness and move between them on each round or sequence
 const (
-	RoundRobin ProposerPolicy = iota
-	Sticky
-	ShuffledRoundRobin
+	RoundRobin         ProposerPolicy = 0
+	ShuffledRoundRobin ProposerPolicy = 2
 )
 
 type Config struct {
diff --git a/consensus/istanbul/core/commit_test.go b/consensus/istanbul/core/commit_test.go
index 89417662c..0162fb787 100644
--- a/consensus/istanbul/core/commit_test.go
+++ b/consensus/istanbul/core/commit_test.go
@@ -283,7 +283,6 @@ func TestVerifyCommit(t *testing.T) {
 			blsPublicKey,
 		},
 	})
-	// }, istanbul.RoundRobin)
 
 	sys := NewTestSystemWithBackend(uint64(1), uint64(0))
 
diff --git a/consensus/istanbul/core/request.go b/consensus/istanbul/core/request.go
index 13b7540c4..c881dbf5d 100644
--- a/consensus/istanbul/core/request.go
+++ b/consensus/istanbul/core/request.go
@@ -17,6 +17,8 @@
 package core
 
 import (
+	"math/big"
+
 	"github.com/ethereum/go-ethereum/common"
 	"github.com/ethereum/go-ethereum/consensus/istanbul"
 )
@@ -64,9 +66,18 @@ func (c *core) checkRequestMsg(request *istanbul.Request) error {
 	}
 }
 
+var (
+	maxNumberForRequestsQueue = big.NewInt(2 << (63 - 2))
+)
+
 func (c *core) storeRequestMsg(request *istanbul.Request) {
 	logger := c.newLogger("func", "storeRequestMsg")
 
+	if request.Proposal.Number().Cmp(maxNumberForRequestsQueue) >= 0 {
+		logger.Debug("Dropping future request", "number", request.Proposal.Number(), "hash", request.Proposal.Hash())
+		return
+	}
+
 	logger.Trace("Store future request", "number", request.Proposal.Number(), "hash", request.Proposal.Hash())
 
 	c.pendingRequestsMu.Lock()
diff --git a/consensus/istanbul/core/roundchange.go b/consensus/istanbul/core/roundchange.go
index 067fcac92..5bf88cfe1 100644
--- a/consensus/istanbul/core/roundchange.go
+++ b/consensus/istanbul/core/roundchange.go
@@ -31,7 +31,7 @@ import (
 func (c *core) sendRoundChange(round *big.Int) {
 	logger := c.newLogger("func", "sendRoundChange", "target_round", round)
 
-	if c.current.View().Round.Cmp(round) >= 0 {
+	if c.CurrentView().Round.Cmp(round) >= 0 {
 		logger.Warn("Cannot send round change for previous round")
 		return
 	}
@@ -62,7 +62,7 @@ func (c *core) sendRoundChangeAgain(addr common.Address) {
 func (c *core) buildRoundChangeMsg(round *big.Int) (*istanbul.Message, error) {
 	nextView := &istanbul.View{
 		Round:    new(big.Int).Set(round),
-		Sequence: new(big.Int).Set(c.current.View().Sequence),
+		Sequence: new(big.Int).Set(c.CurrentView().Sequence),
 	}
 
 	rc := &istanbul.RoundChange{
diff --git a/consensus/istanbul/validator/selectors.go b/consensus/istanbul/validator/selectors.go
index 89688ce28..ed9e47d53 100644
--- a/consensus/istanbul/validator/selectors.go
+++ b/consensus/istanbul/validator/selectors.go
@@ -73,23 +73,9 @@ func RoundRobinProposer(valSet istanbul.ValidatorSet, proposer common.Address, r
 	return valSet.List()[idx%uint64(valSet.Size())]
 }
 
-// StickyProposer selects the next proposer with a sticky strategy, advancing on round change.
-func StickyProposer(valSet istanbul.ValidatorSet, proposer common.Address, round uint64) istanbul.Validator {
-	if valSet.Size() == 0 {
-		return nil
-	}
-	idx := round
-	if proposer != (common.Address{}) {
-		idx += proposerIndex(valSet, proposer)
-	}
-	return valSet.List()[idx%uint64(valSet.Size())]
-}
-
 // GetProposerSelector returns the ProposerSelector for the given Policy
 func GetProposerSelector(pp istanbul.ProposerPolicy) istanbul.ProposerSelector {
 	switch pp {
-	case istanbul.Sticky:
-		return StickyProposer
 	case istanbul.RoundRobin:
 		return RoundRobinProposer
 	case istanbul.ShuffledRoundRobin:
diff --git a/consensus/istanbul/validator/selectors_test.go b/consensus/istanbul/validator/selectors_test.go
index 0b703c6d9..466ff9753 100644
--- a/consensus/istanbul/validator/selectors_test.go
+++ b/consensus/istanbul/validator/selectors_test.go
@@ -33,63 +33,6 @@ var testAddresses = []string{
 	"0000000000000000000000000000000000000005",
 }
 
-func TestStickyProposer(t *testing.T) {
-	var addrs []common.Address
-	var validators []istanbul.Validator
-	for _, strAddr := range testAddresses {
-		addr := common.HexToAddress(strAddr)
-		addrs = append(addrs, addr)
-		validators = append(validators, New(addr, nil))
-	}
-
-	v, err := istanbul.CombineIstanbulExtraToValidatorData(addrs, make([][]byte, len(addrs)))
-	if err != nil {
-		t.Fatalf("CombineIstanbulExtraToValidatorData(...): %v", err)
-	}
-	valSet := newDefaultSet(v)
-	selector := GetProposerSelector(istanbul.Sticky)
-
-	cases := []struct {
-		lastProposer common.Address
-		round        uint64
-		want         istanbul.Validator
-	}{{
-		lastProposer: addrs[0],
-		round:        0,
-		want:         validators[0],
-	}, {
-		lastProposer: addrs[0],
-		round:        1,
-		want:         validators[1],
-	}, {
-		lastProposer: addrs[0],
-		round:        2,
-		want:         validators[2],
-	}, {
-		lastProposer: addrs[2],
-		round:        2,
-		want:         validators[4],
-	}, {
-		lastProposer: addrs[2],
-		round:        3,
-		want:         validators[0],
-	}, {
-		lastProposer: common.Address{},
-		round:        3,
-		want:         validators[3],
-	}}
-
-	for i, c := range cases {
-		t.Run(fmt.Sprintf("case:%d", i), func(t *testing.T) {
-			t.Logf("selectProposer(%s, %d)", c.lastProposer.String(), c.round)
-			proposer := selector(valSet, c.lastProposer, c.round)
-			if val := proposer; !reflect.DeepEqual(val, c.want) {
-				t.Errorf("proposer mismatch: have %v, want %v", val, c.want)
-			}
-		})
-	}
-}
-
 func TestRoundRobinProposer(t *testing.T) {
 	var addrs []common.Address
 	var validators []istanbul.Validator
